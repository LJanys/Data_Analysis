[
["problem-set-4-np-density-estimation.html", "Chapter 14 Problem Set 4: NP-Density estimation 14.1 Generate a sample of 100 points from a distribution of your choice and program (by hand) the kernel density estimator", " Chapter 14 Problem Set 4: NP-Density estimation 14.1 Generate a sample of 100 points from a distribution of your choice and program (by hand) the kernel density estimator \\[\\hat{f}(x)=\\frac{1}{nh}\\sum_{i=1}^nK\\left(\\frac{x-X_i}{h} \\right)\\] using the Epanechnikov Kernel below and plot the resulting function estimate. \\[K(x)=\\frac{3}{4}\\left(1-|x|^2 \\right)\\mathbf{1}(|x|\\leq 1)\\] #Nonparametric Density Estimation# #We define the functions used for the Kernel function# # Gaussian Kernel ################################### kern1&lt;-function(x) { kern1&lt;-(2*pi)^(-1/2)* exp(-x^2/2) return(kern1) } ###Or: Gaussian Kernel ################################### Gauss.kernel &lt;- function(phi,...) { dnorm(phi) } # Epanechnikov Kernel: ############################# kern2&lt;-function(x) { kern2&lt;-c() for(i in 1:length(x)) { if(abs(x[i])&lt;=1) { kern2[i]&lt;-3/4*(1-x[i]^2) } else{kern2=0} } return(kern2) } ##Or: # Epanechnikov Kernel: ############################# Epan.kernel &lt;- function(phi,...) { 0.75*(1-phi^2)*(abs(phi)&lt;=1) } z&lt;-seq(-1,1,length.out=100) ###Plot the Kernel functions over the same x-values### plot(z,kern2(z),lty=1,type=&quot;l&quot;,col=&quot;springgreen4&quot;,lwd=2 , ylab=&quot;&quot;) lines(z,kern1(z),lty=2,type=&quot;l&quot;,col=&quot;navy&quot;,lwd=2) legend(x= &quot;bottomleft&quot;, y=0.95, legend=c(&quot;Epanechnikov Kernel&quot;,&quot;Gaussian Kernel&quot;),col=c(&quot;springgreen4&quot;,&quot;navy&quot;), lty=1:2, cex=1) ####The density estimator### N.grid &lt;- 100 N.sam &lt;- 100 #------------------ QUANT.LOW &lt;- 0.05 QUANT.HIGH &lt;- 0.95 x.grid &lt;- seq(qnorm(QUANT.LOW),qnorm(QUANT.HIGH),length.out=N.grid) #Generate a function for the true density dens.true &lt;- function(x,...){ dens &lt;- (qnorm(QUANT.LOW)&lt;=x)*(x&lt;=qnorm(QUANT.HIGH))*dnorm(x)/(QUANT.HIGH-QUANT.LOW) } ####Plot the true density############## curve(dens.true,from=-2,to=2) dens.grid &lt;- dens.true(x.grid) # Generate a sample of 100 points ######################################################## set.seed(1048) x.sample &lt;- vector(&quot;double&quot;,length=N.sam) count &lt;- 1 while(count &lt;= length(x.sample)){ temp &lt;- rnorm(1) if(temp&lt;qnorm(QUANT.LOW)|temp&gt;qnorm(QUANT.HIGH)){ count &lt;- count ##we draw from a standard normal distribution, create a temporary variable and see whether it is within our grid interval. If not we draw again. If yes, we move to the next draw. } else{ x.sample[count] &lt;- temp count &lt;- count + 1 } } ####--------------------The actual density estimator------## dens.estim &lt;- function(x.grid,x.data,h,Kern=Epan.kernel,...){ # Number of sample observations N &lt;- length(x.data) # Number of points at which to evaluate n.grid &lt;- length(x.grid) dens.est &lt;- vector(&quot;double&quot;,length=n.grid) for(i in 1:length(x.grid)){ phi &lt;- (x.data - x.grid[i])/h dens.est[i] &lt;- mean(1/h*Kern(phi)) } return(dens.est) } ##Calculate the estimator for different bandwidths##### reps=30 h.grid&lt;-seq(0.1,0.8,le=reps)###Consider Bandwidths between 0.01 and 0.5 res&lt;-matrix(NA,length(x.sample),reps) for(i in 1:reps) { res[,i]&lt;- dens.estim(x.grid=x.grid,x.data=x.sample,h=h.grid[i],Kern=Epan.kernel) } res.df&lt;-as.data.frame(cbind(as.factor(x.grid),res)) names(res.df)&lt;-c(&quot;x.grid&quot;, sprintf(&quot;%s&quot;,round(h.grid,2))) library(&quot;reshape2&quot;) library(&quot;ggplot2&quot;) test_data_long &lt;- melt(res.df, id=&quot;x.grid&quot;) names(test_data_long)=c(&quot;x&quot;,&quot;Bandwidth&quot;,&quot;Density&quot;) plot=ggplot(data=test_data_long, aes(x=x, y=Density, colour=Bandwidth)) +geom_line() plot+ scale_colour_grey(start = 0.8, end = 0.2)+theme(legend.position = &quot;none&quot;)+ theme_bw() "]
]
