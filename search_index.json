[
["exercises-simple-data-structures.html", "Chapter 5 Exercises: Simple Data structures 5.1 R as a calculator 5.2 Numerical and Nonnumerical Objects 5.3 Vectors", " Chapter 5 Exercises: Simple Data structures 5.1 R as a calculator 1.8+2 1.8-2 1.8*2 1.8/2 2+2*3 (2+2)*3 2^3 8^(1/3) 3^2 9^0.5 2^2*2+2 2^(2*((0.2+0.3)*(1+2)))+4 sqrt(2) exp(1) exp(2) log(7.389056) log(exp(3)) log(100,10) abs(1.8-2) round(sqrt(2),2) round(sqrt(2),4) pi sin(pi/2) sin(pi/2) sin(pi) tan(pi) x=2+3i y=4+1i x y x+y x*y 5.2 Numerical and Nonnumerical Objects x=2 x x+1 x=&quot;Hallo Welt&quot; x x+2 x=z x=&quot;z&quot; x x+2 5.3 Vectors #Scalars s1&lt;-0.8 s2&lt;-2.4 s3&lt;-c(-3.4) s1 s2 #Construction of vectors v1&lt;-c(s1,s2,s3) v1 v2&lt;-c(1,2,3) v2 v3=c(v1,4,5) v3 v4=c(c(4,2,3),v3,c(3,8),s3,1,2,c(v1,v2,v3)) v4 Name=c(&quot;Anton&quot;,&quot;Berta&quot;,&quot;Caesar&quot;,&quot;Dora&quot;,&quot;Emil&quot;) Geschlecht=c(&quot;m&quot;,&quot;w&quot;,&quot;m&quot;,&quot;w&quot;,&quot;m&quot;) Groesse=c(182,174,189,165,180) Gewicht=c(80,68,92,55,78) Name Geschlecht Groesse Gewicht #Construction of special vectors seq(2,30,by=0.1) seq(2,30,le=4) seq(2,30,4) seq(2,30,5) seq(2,30,10) seq(10,3,-2) rep(1,3) rep(3,1) rep(2,4) rep(4,2) v1 rep(v1,3) 1:4 2:7 10:3 1.5:4.8 #Accessing vector components Name length(Name) Name[1] Name[2] Name[c(1,2)] Name[1:3] Name[-2] Name[-c(1,2)] length(Groesse) Groesse[1] Groesse[1:3] Groesse[-(1:3)] #Calculating with vectors c(1,2,3)+1 c(1,2,3)+c(3,2,1) c(1,2,3,4,5)+c(1,2,3) c(1,2,3)*2 c(1,2,3)*c(3,2,1) c(1,2,3)%*%c(3,2,1) c(1,2,3)/2 c(1,2,3)/c(3,2,1) "],
["construction-of-matrices.html", "Chapter 6 Construction of matrices", " Chapter 6 Construction of matrices v=1:12 v m1=matrix(v,3,4) m1 m2=matrix(v,4,3) m2 matrix(v,3,4,byrow=T) matrix(v,4,4) matrix(v,5,5) matrix(v,2,2) m3=cbind(m1,c(13,14,15)) m3 cbind(c(1,2,3),c(4,5,6)) m4=rbind(m2,c(5,9,13)) m4 cbind(c(1,2,3),c(4,5,6)) #Accessing matrix components m1 m1[1,] m1[2,] m1[,4] m1[1,1] m1[2,2] m1[c(1,3),2:3] m1[,-4] c=dim(m1) #Calculating with matrices m1=matrix(c(1,4,3,0),2,2) m2=matrix(c(1,2,3,2),2,2) m1 m2 m1+1 m1+m2 m1-m2 m1*2 m1*m2 m1/2 m1/m2 m1%*%m2 t(m1) solve(m1) m1%*%solve(m1) "],
["construction-of-lists.html", "Chapter 7 Construction of Lists", " Chapter 7 Construction of Lists v=c(&quot;Hallo&quot;,&quot;Tag&quot;,&quot;Hi&quot;,&quot;Guten Tag&quot;) m=matrix(1:9,3,3) v m objekte=list(v,m) objekte #Accessing list components objekte[[1]] objekte[[2]] length(objekte) objekte[[1]][2] objekte[[2]][,2] objekte=list(Begruessungen=v,Zahlenmatrix=m) objekte$Begruessungen objekte$Zahlenmatrix names(objekte) #Data Frames Name Geschlecht Groesse Gewicht cbind(Name, Geschlecht, Groesse, Gewicht) Personen=data.frame(Name, Geschlecht, Groesse, Gewicht) summary(Personen) #Accessing data frame coomponents length(Personen) Personen[[1]] Personen[[4]] names(Personen) Personen$Name Personen$Gewicht dim(Personen) Personen[1,1] Personen[5,4] Personen[1,1] Personen[5,4] #Logical Expressions x=c(8,5,5,1,6,9,7,4) c=x&lt;6 x&gt;3 x==5 x!=5 2&lt;x&amp;x&lt;8 x&lt;4|x&gt;6 sum(x&gt;3) sum(x&lt;4|x&gt;6) x[]&gt;2###Returns a logical vector ## y&lt;-seq(1,8,by=1) y[x&gt;4]#returns all elements for which a logical expression is fulfilled #Subsetting data frames Personen subset(Personen,Geschlecht==&quot;m&quot;) subset(Personen,Groesse&gt;180) subset(Personen,Geschlecht==&quot;m&quot;,select=Name) subset(Personen,Groesse&gt;180,select=c(Groesse,Gewicht)) Maenner=subset(Personen,Geschlecht==&quot;m&quot;) #Ordering data x=c(4,6,2,7,9,1,5,4) x sort(x) x sort(x,decreasing=T) rank(x) order(x) #Summing data x=c(1,1,5,2,1,5,2,3,10,2) n=length(x) n Y&lt;-cbind(rep(1,n),x) sum(x) cumsum(x) colSums (Y) rowSums (Y) colMeans(Y) rowMeans(Y) #Frequencies - onedimensional table(x) x table(x)/n klassen=hist(x,breaks=(c(0,2,5,10))) klassen$counts klassen$counts/n #Mehrdimensional x=c(1,1,1,2,1,3,3,2,1,3) y=c(0,0,0,1,0,0,1,1,0,1) z=c(&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;) data.frame(x,y,z) table(x,y) table(x,y,z)## two-dimensional frequency table ##Conditional frequencies m=table(x,y) m #Calculates row frequencies prop.table(m,1) #Calculates column frequencies prop.table(m,2) ##Statistical distribution #Normal distribution x=seq(-5,4,le=1000) y=dnorm(x) plot(x,y) plot(x,y,type=&quot;l&quot;) z=dnorm(x,1,2) plot(x,z,type=&quot;l&quot;) pnorm(0) pnorm(0,1,2) pnorm(1,1,2) ##Calculations pnorm(3,1,2)-pnorm(2,1,2) qnorm(0.6,1,2) x=rnorm(1000,1,2) hist(x,prob=T) ##Binomial distribution dbinom(8,10,0.5) pbinom(6,10,0.5)-pbinom(2,10,0.5) qbinom(c(0.25,0.5,0.75),10,0.5) rbinom(20,1,0.5) x=0:20 y=dbinom(x,20,0.5) plot(x,y,type=&quot;h&quot;) #Repeated random draws# rbinom(20,10,0.5) set.seed(32323) rbinom(20,10,0.5) set.seed(32323) rbinom(20,10,0.5) set.seed(32323) rbinom(20,10,0.5) #For-Loops #Example 1 x=0 for (i in 1:3) { x=x+i } x # Example 2 x=0 for (i in 1:3) { x=x+i z=x*i } z #Simulationstudy: Law of large numbers # RelShare=c() ###initialize an empty vector&quot; N=500#Number of draws for (n in 1:N)#initialize the loop { Sample=rbinom(n,1,0.5)#draw a vector with RelShare[n]=mean(Sample)#calculate the number of ones } plot(1:N,RelShare,#plot the results main=&quot;B(1,0.5)-Distribution-Law of large numbers&quot;, xlab=&quot;n&quot;,ylab=&quot;Relative Share&quot;,pch=16, cex.axis=1,cex.lab=1,cex.main=1) abline(h=0.5,lwd=2,col=2)#We add a line with the expected value ###If-condition### y&lt;-c(1,4,5,2,7,8,2,4) N &lt;- length(y) 1:N ## y.sq &lt;- numeric(N)#initialize an empty vector of length N y.sq#print ## for(i in 1:N){ # initialize the for-loop y.sq[i] &lt;- y[i]^2#every element of y is squared and replaces the i&#39;th element in the empty vector with the result if(i == N){# only when condition is fulfilled , i.e. only in the last run of the loop print(y.sq)#print y.sq in the console } } ##Variation### y&lt;-c(1,4,5,2,7,8,2,4) N &lt;- length(y) 1:N ## y.sq &lt;- numeric(N)#initialize an empty vector of length N y.sq#print ## for(i in 1:N){ # # initialize the for-loop if(y[i] &gt; 4){ ##if condition is fulfilled, i.e. if y[i] is larger than 4 y.sq[i] &lt;- y[i]^2#every element of y is squared and replaces the i&#39;th element in the empty vector with the result } else{ ##if elements of y are smaller or equal to 4: y.sq[i]&lt;-0## replace the elements with zero } } y.sq #Functions: write a function that calculates the (biased) variance vartilde=function(x) { mean(x^2)-mean(x)^2 } y&lt;-rnorm(100) vartilde(x=y)#Call the function vartilde var(y) ##functions with many arguments GGZGraph=function(N=100,pi=0.5) { RelShare=c() for (n in 1:N) { Sample=rbinom(n,1,pi) RelShare[n]=mean(Sample) } plot(1:N, RelShare, main=&quot;LLN&quot;, xlab=&quot;n&quot;,ylab=&quot;Relative Share&quot;,pch=16, cex.axis=1,cex.lab=1,cex.main=1) abline(h=pi,lwd=2,col=2) } GGZGraph() #Simulation GGZGraph(100,0.4) GGZGraph(1000,0.4) ##Return of several values GGZSim=function(N=100,pi=0.5,a,b) { RelShare=c() for (n in 1:N) { Sample=rbinom(n,1,pi) RelShare[n]=mean(Sample) } IntervallAnt=sum(a&lt; RelShare&amp; RelShare&lt;b)/N list( RelShare,IntervallAnt) } result=GGZSim(100,pi=0.5,a=0.4,b=0.6) result[[2]] ###Or### GGZSim2=function(N=100,pi=0.5,a,b) { RelShare=c() for (n in 1:N) { Sample=rbinom(n,1,pi) RelShare[n]=mean(Sample) } IntervallAnt=sum(a&lt;RelShare&amp;RelShare&lt;b)/N return=list(RelShare=RelShare,IntervallAnt=IntervallAnt) } result2=GGZSim2(N=100,pi=0.5,a=0.4,0.6) result2$IntervallAnt "]
]
